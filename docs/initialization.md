# Initialization

Initialization involves calling one of two functions `initialize_with_endpoint` or `initialize_with_json`. Both of these functions work almost identically in that they accept some path to a specification or the OpenAPI specification itself, along with a user defined configuration. Both functions also return a tuple of dictionaries, one for the Models, and one for the functions that the Magellan Models can't access (healthcheck etc).

```python
from magellan_models.initializers import initialize_with_endpoint
from magellan_models.config import MagellanConfig

myCustomizedConfig = MagellanConfig()
models, funcs, config = initialize_with_endpoint("https://myurl/myopenapi.json", myCustomizedConfig)
```

## Specification Information

If you want to pass in a specification, you can either pass in a python dict object using `initialize_with_spec` and then that dictionary will be parsed as if it's a JSON Schema object.

Alternatively if you know the path to your endpoint's openapi.json, you could just pass in that URL into the `initialize_with_endpoint` function, in which case you'll let the Magellan initializer send a Requests GET request over to that endpoint and then parse whatever that OpenAPI.json file returns.

## Configuration

If you don't pass in a configuration, then the Magellan initializer will create a default one for you and return it to you in the Models dict (first element of the tuple). You can modify the configuration to alter the behavior of the models and functions generated however you won't be able to change how the specification was parsed after the parsing is complete.

See the configuration.md documentation to get a better idea of what options you have to change and modify the config.

## Returned Objects

The initialize functions return a tuple `(models, funcs, config)` with two dict objects. One is for the MagellanModels and the other is for the non Model routes. The last value in the tuple is a reference to the MagellanConfig instance that's linked to both the models and routes.

### Models

The first dict is the Models dict and is a mapping of Model names to Model type definitions. You can print out the keys of this dict to get an idea of what models where generated. This dict also contains a "__configuration" key which returns the Configuration object. This is useful if you're using the autogenerated configuration or if you want to pull the configuration and modify it later in your code.

```python
models, funcs, config = initialize_with_json(myJson, myConf)

print(models.keys()) # => ["Sample", "Lab", "Test", "__configuration"]
Lab = models["Lab"]

Lab.find_by_title("SeathForce").uuid # some UUID string
```

### Functions

The second dict is a mapping of helper functions that call routes not connected to any of the Magellan Models. Each function accepts a payload which is sent alongside the request. Each function returns a Requests.response object.

```python
models, funcs, config = initialize_with_json(myJson, myConf)
funcs.keys() # => ["get_from_healthcheck", "post_to_upload", ...]
resp = get_from_healthcheck()
res.json() # => {"status": 200, "message": "Hello World. All is well"}
```

These functions are a little unweildy but provided for the user to utilize as needed. You can also pass in direct arguments into the `requests` library by passing in arguments as `kwargs`.

#### Generic API Access Function

A generic API access function is also provided under the key `_generic_api_function`. This function lets you pass in a path, request type, and JSON body and it returns the Requests.response for that request. This function really just generates the path and header for you before relying on the `Requests` library to do the heavy lifting but is provided for cases where the Magellan faux-ORM or functions won't suffice for your use case. For example, we might want to get the `meta` body for a response object but Magellan discards that metadata in the faux-ORM calls. We can use this generic function to make a call to the same endpoint and extract the data that we need instead.

```python
# Given our previously generated models, and funcs from above... 
api_query_func = funcs['_generic_api_function']

resp = api_query_func("/labs?filter=[{"name": "creator_id", "op": "eq", "val": "12345"}]", method="GET")

if resp.status_code == 200:
    print(resp.json().get("meta", {}).get("total-count", "total-count is missing"))
```
